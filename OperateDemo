class OperateDemo {
	public static void main(String[] agrs){
//算术运算符：+ - * / (加减乘除) %（取余，模运算）/*	+	也能作为连接符号,任何数据和字符串相连接，+的作用都是相连接*/
    int a=6370,b=98;
	a=a/1000*1000;
    System.out.println("a="+a);	//结果为6000（因为6370/1000结果为6.37。但是int是没有小数的，所以只取整数6，6*1000=6000）
    int x=5,y=2,z;	//z代表商，r代表余（模）
    System.out.println("r="+x%y);	//取余(计算模或者余数： r = a - z*b.)，r（余）=5-2(商)*2
    System.out.println("r="+y%x);	//r= 2-0(商)*5
    x=-5;
    System.out.println("r="+x%y);	//涉及负数运算时，负号只参考被模数a。r=-5-(-2商)*2  , r=-1
    System.out.println("a="+5+5);	//a=55,运算过程为"a=5"+5, 然后再次连接"a=55",结果为：a=55
    System.out.println("a="+(5+5));	//a=10,运算过程为，按优先级先算括号内的算"a="+10, 然后再次连接"a=10",结果为：a=10
    a=3;
    b=4;
    System.out.println("a="+a+",b="+b);	//结果为 a=3,b=4

//++(自增:自增在左先自加后赋值，在右先赋值再自加)	--(自减：自减在左先自减后赋值，在右先赋值再自减)
    a=25;
    b=a++;	//a先赋值给b，a再自加
    System.out.println("a="+a+",b="+b);	//运算过程为：系统先把a的值暂存到一个区域，然后a自加，得出a的值后，再把暂存的a的值赋给b。
    a=35;
    b=++a;
    System.out.println("a="+a+",b="+b);	//运算过程为:a自加，然后把自加后的a赋值给b
    a=5;
    a=a++;
    System.out.println("a="+a);		//a=5，系统先把a的值暂存到一个区域，然后a自加，自加完成后，暂存的a的值再覆盖掉自加后的a值

//赋值运算：=	+=	-=	*=	/=
    int d,e,f;
    d=e=f=4;
    System.out.println(d);
    d+=2;	//d=d+2
    System.out.println("d="+d);	//结果为6
    short g=50;
    g+=3;	//结果和g=g+3一样，但可以编译，因为“+=”是一个赋值运算，是一个符号，系统会在右边的运算完成后做自动转换动作，运算过程：g=(short)(g+4)
    System.out.println("g="+g);
    //g=g+3;	//无法编译，因为short只有两字节，而3是Int型四字节，系统没有做自动转换，丢失精度。如果要编译必须做强转：g=(short)(g+4)这样强转以后才能编译

//比较运算符：>(大于)	<（小于）	>=（大于或等于）	<=（小或等于） !=（不等于） ==（等于）
    //比较运算符，运算结果都是boolean型，不是"true"就是"false"
    //注意不要把比较运算符"=="，误写成"="
    a = 10;
    b = 20;
    System.out.println("a == b : " + (a == b) );	//结果为false
    System.out.println("a != b :" + (a != b) );		//结果为true
    System.out.println("a > b : " + (a > b) );		//结果为false
    System.out.println("a < b : " + (a < b) );		//结果为true
    System.out.println("b >= a : " + (b >= a) );	//结果为true
    System.out.println("b <= a : " + (b <= a) );	//结果为false

//逻辑运算符:	&(逻辑与)	|(逻辑或)	!(逻辑非)	^(异或)
    //短路逻辑运算符：&&(与,具有短路性，如果左边为flase，右边不执行)	||(或，具有短路性，如果左边为flase，右边不执行)
    //作用：用于连接两个boolean类型的表达式
    a=5;
    b=6;
    //&(与)运算:两边都为true，结果才为true。不管左边是否为true，右边都会运算。
    System.out.println("a<b&a>b="+(a<b&a>b));	//结果为false，因为右边的运算为false

    //|(或)运算:左右只要有一边为true，结果就为true。只有两边都为false时，结果才为false.
    System.out.println("a<b|a>b="+(a<b|a>b));	//结果为true，因为左边的结果为true

    //!(非)运算:用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false
    System.out.println("!(a<b)="+!(a<b));		//结果为false，因为5<6得到的值是true
	System.out.println("!!(a>b)="+!!(a>b));	//结果为false，因为两次否定，为肯定。首次计算为!false输出true,又一次非运算!true最后结果输出false。

	//^(异或)运算：两边都为true或都为false，结果为false，两边只有一个true得true
	System.out.println("a<b^a>b="+(a<b^a>b));	//结果为true，因为两边的结果不相同
	/*面试题：&&	||
	&&(短路与)运算：只要左边不为true，右边就停止运算，输出false
	||(短路或)运算：当左边为true时，右边就停止运算，输出true	*/
	
//位运算符：位与'&'，位或'|'，位非'~'，位异或'^'，右移'>>'，左移'<<'，0填充的右移'>>>' 
}
}
